# Specification



You will implement autocomplete in two different ways.

- **BruteForceAutocomplete.java**, a brute-force solution.
- **QuickAutocomplete.java**, will use a more complex data structure (of your own design) to improve performance.

As you will know from using autocomplete, speed is important. It should be quick to return the suggested list within 50ms to be acceptable to a user.

##BruteForceAutocomplete.java

Write an data type BruteAutocomplete.java that implements the API shown below. Your brute-force implementation should maintain the terms and weights in a suitable implementation of **List**.

~~~ java
public interface AutoCompleteInterface {

	// Returns the weight of the term, or 0.0 if no such term.
	public double weightOf(String term);

	// Returns a top matching term, or null if no matching term.
	public String topMatch(String prefix);

	// Returns the top k matching terms (in descending order of weight), as an
	// iterable.
	// If fewer than k matches, return all matching terms (in descending order
	// of weight).
	public Iterable<String> topMatches(String prefix, int k);
}
~~~

### Implementation Details
- **Constructor:** The constructor should throw an IllegalArgumentException unless the arguments are valid: a List of terms; the weights are strictly positive; and no term is included more than once.
- To find the top k matching terms, scan through all of the terms, identifying those that start with the given prefix, and return the top k such terms.
- The topMatches() method should throw a IllegalArgumentException if k is negative.
- Each method and constructor should throw a NullPointerException if any argument is null.

This brute-force approach is easy to implement but, when N is large, the number of autocomplete queries that can be processed per second will be too small to be useful. You can use it as a reference solution and benchmark when developing a faster solution.

Your constructor for BruteAutocomplete should be subquadratic in the number of terms, and your topMatch() and topMatches() methods should be subquadratic in the number of terms (and thus you should not use your weightOf method if it is linear time).

##Autocorrect Application
Use the api to develop an end user application. This can be a simple command line interface that allows a user to access the functionality in the Autocomplete API.
